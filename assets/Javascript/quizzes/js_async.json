{
  "result": [
    {
      "topic": "js_async",
      "questions": [
        {
          "question": "What is a callback in JavaScript?",
          "options": {
            "A": "A function that is passed as an argument to another function",
            "B": "A method that gets called when an object is created",
            "C": "A function that returns a promise",
            "D": "A function that has no parameters"
          },
          "correct_answer": "A"
        },
        {
          "question": "What is the primary purpose of asynchronous programming?",
          "options": {
            "A": "To execute multiple tasks simultaneously",
            "B": "To simplify synchronous code",
            "C": "To block code execution until a task completes",
            "D": "To improve code readability"
          },
          "correct_answer": "A"
        },
        {
          "question": "What does a Promise represent in JavaScript?",
          "options": {
            "A": "A value that will be available in the future",
            "B": "A function that is always executed",
            "C": "A method that resolves immediately",
            "D": "An object that can be modified"
          },
          "correct_answer": "A"
        },
        {
          "question": "Which method is used to handle a fulfilled promise?",
          "options": {
            "A": ".catch()",
            "B": ".then()",
            "C": ".finally()",
            "D": ".resolve()"
          },
          "correct_answer": "B"
        },
        {
          "question": "What does the async keyword do when used before a function?",
          "options": {
            "A": "It makes the function return a promise",
            "B": "It prevents the function from executing",
            "C": "It allows the function to run synchronously",
            "D": "It creates a generator function"
          },
          "correct_answer": "A"
        },
        {
          "question": "How do you handle errors in an async function?",
          "options": {
            "A": "Using try/catch blocks",
            "B": "Using the .catch() method",
            "C": "Returning an error object",
            "D": "Using error callbacks"
          },
          "correct_answer": "A"
        },
        {
          "question": "What is the purpose of the await keyword?",
          "options": {
            "A": "To pause the execution of an async function until a promise resolves",
            "B": "To create a new promise",
            "C": "To execute a synchronous function",
            "D": "To return multiple values from a function"
          },
          "correct_answer": "A"
        },
        {
          "question": "Which of the following will NOT return a promise?",
          "options": {
            "A": "fetch()",
            "B": "new Promise()",
            "C": "setTimeout()",
            "D": "Promise.resolve()"
          },
          "correct_answer": "C"
        },
        {
          "question": "What happens if you do not return a value from an async function?",
          "options": {
            "A": "It returns undefined",
            "B": "It throws an error",
            "C": "It resolves to null",
            "D": "It creates an infinite loop"
          },
          "correct_answer": "A"
        },
        {
          "question": "What will the following code output: console.log(Promise.resolve(2) + 2)?",
          "options": {
            "A": "2",
            "B": "22",
            "C": "Promise {2}",
            "D": "Error"
          },
          "correct_answer": "B"
        },
        {
          "question": "What does it mean for a function to be asynchronous?",
          "options": {
            "A": "It runs in parallel with other functions",
            "B": "It blocks the main thread until completion",
            "C": "It can return a promise",
            "D": "Both A and C"
          },
          "correct_answer": "D"
        },
        {
          "question": "Which of the following is true about promises?",
          "options": {
            "A": "They can be in one of three states: pending, fulfilled, or rejected.",
            "B": "They can only be in a fulfilled state.",
            "C": "They can be created only using the async/await syntax.",
            "D": "They automatically resolve without any callback."
          },
          "correct_answer": "A"
        },
        {
          "question": "How do you convert a regular function to return a promise?",
          "options": {
            "A": "By using the async keyword",
            "B": "By wrapping it in a Promise constructor",
            "C": "By using the await keyword",
            "D": "By adding .then() to it"
          },
          "correct_answer": "B"
        },
        {
          "question": "What will the following code output? 'Promise.resolve(3).then(v => v + 1).then(v => console.log(v));'",
          "options": {
            "A": "3",
            "B": "4",
            "C": "Error",
            "D": "Promise {4}"
          },
          "correct_answer": "B"
        },
        {
          "question": "What is the main advantage of using async/await over traditional promise chaining?",
          "options": {
            "A": "It makes the code more readable and easier to understand.",
            "B": "It eliminates the need for promises entirely.",
            "C": "It executes all promises simultaneously.",
            "D": "It automatically handles errors."
          },
          "correct_answer": "A"
        },
        {
          "question": "Which of the following can be used to run multiple promises concurrently?",
          "options": {
            "A": "Promise.all()",
            "B": "Promise.race()",
            "C": "async/await",
            "D": "setTimeout()"
          },
          "correct_answer": "A"
        },
        {
          "question": "What will happen if you use await on a non-promise value?",
          "options": {
            "A": "It will throw an error.",
            "B": "It will convert the value to a promise.",
            "C": "It will immediately resolve with that value.",
            "D": "It will block the event loop."
          },
          "correct_answer": "C"
        },
        {
          "question": "How can you handle multiple errors when using async/await?",
          "options": {
            "A": "Using a try/catch block around the await calls.",
            "B": "Using .catch() after the function call.",
            "C": "Returning a promise that resolves to an error object.",
            "D": "Using an error handler function."
          },
          "correct_answer": "A"
        },
        {
          "question": "What is the purpose of the Promise.allSettled() method?",
          "options": {
            "A": "To execute promises in parallel and wait until all are resolved or rejected.",
            "B": "To execute promises in sequence.",
            "C": "To return the first settled promise only.",
            "D": "To handle errors from all promises."
          },
          "correct_answer": "A"
        },
        {
          "question": "Which of the following is a valid use of async/await?",
          "options": {
            "A": "await Promise.resolve()",
            "B": "await 1 + 2",
            "C": "async function() { return 3; }",
            "D": "await setTimeout(() => {}, 1000)"
          },
          "correct_answer": "A"
        }
      ]
    }
  ]
}
