{
  "result": [
    {
      "topic": "Introduction_to_NumPy",
      "questions": [
        {
          "question": "What is NumPy primarily used for in Python?",
          "options": {
            "A": "For creating graphical user interfaces.",
            "B": "For numerical computations and working with arrays.",
            "C": "For web development.",
            "D": "For handling large text files."
          },
          "correct_answer": "B",
          "explanation": "NumPy (Numerical Python) is a fundamental library for numerical computing in Python. Its core strength lies in providing a powerful `ndarray` object for efficient storage and manipulation of large, multi-dimensional arrays and a vast collection of high-level mathematical functions to operate on these arrays."
        },
        {
          "question": "Which of the following is a key advantage of using NumPy arrays over standard Python lists for numerical operations?",
          "options": {
            "A": "They are more flexible in terms of data types within the same array.",
            "B": "They offer significantly better performance for large numerical computations.",
            "C": "They can be easily resized after creation.",
            "D": "They support a wider range of built-in mathematical functions."
          },
          "correct_answer": "B",
          "explanation": "NumPy arrays are implemented in C and Fortran, making them significantly faster and more memory-efficient than Python lists for numerical operations, especially with large datasets. This performance boost is due to their homogeneous nature (all elements are of the same data type) and contiguous memory storage."
        },
        {
          "question": "How can you install NumPy in a Python environment?",
          "options": {
            "A": "Using the command `install numpy` in the Python interpreter.",
            "B": "By downloading the NumPy source code and running a setup script.",
            "C": "Using a package manager like pip with the command `pip install numpy`.",
            "D": "NumPy comes pre-installed with standard Python distributions."
          },
          "correct_answer": "C",
          "explanation": "The standard and recommended way to install NumPy (and most other Python packages) is by using the pip package manager. The command `pip install numpy` downloads and installs the package and its dependencies from PyPI (Python Package Index)."
        },
        {
          "question": "What is the core data structure provided by NumPy?",
          "options": {
            "A": "List",
            "B": "Tuple",
            "C": "ndarray",
            "D": "Series"
          },
          "correct_answer": "C",
          "explanation": "The core data structure in NumPy is the **`ndarray`** (N-dimensional array) object. This object is a multi-dimensional container of items of the same type and size. It provides efficient storage and mathematical operations over large arrays."
        },
        {
          "question": "Which of the following is a characteristic of a NumPy ndarray?",
          "options": {
            "A": "It can store elements of different data types within the same array.",
            "B": "It has a fixed size upon creation.",
            "C": "Its elements are not necessarily stored in contiguous memory locations.",
            "D": "It is less memory-efficient than Python lists for numerical data."
          },
          "correct_answer": "B",
          "explanation": "A key characteristic of a NumPy `ndarray` is that it has a **fixed size upon creation**. Once created, you cannot change its size directly without creating a new array. This fixed size, along with homogeneous data types and contiguous memory storage, contributes to its performance benefits."
        },
        {
          "question": "What does the 'dtype' attribute of a NumPy array represent?",
          "options": {
            "A": "The number of dimensions of the array.",
            "B": "The shape of the array (number of elements in each dimension).",
            "C": "The data type of the elements stored in the array.",
            "D": "The total number of elements in the array."
          },
          "correct_answer": "C",
          "explanation": "The `dtype` attribute of a NumPy array specifies the **data type of the elements** stored within the array (e.g., `int32`, `float64`, `bool`). All elements in a NumPy array must have the same data type, which is why `dtype` is an important property."
        },
        {
          "question": "Which NumPy function can be used to create a NumPy array from a Python list?",
          "options": {
            "A": "numpy.aslist()",
            "B": "numpy.fromlist()",
            "C": "numpy.array()",
            "D": "numpy.convert_to_array()"
          },
          "correct_answer": "C",
          "explanation": "The most common and direct way to create a NumPy array from an existing Python list (or tuple) is by using the `numpy.array()` function. For example: `np.array([1, 2, 3])`."
        },
        {
          "question": "How can you create a NumPy array filled with zeros?",
          "options": {
            "A": "numpy.empty()",
            "B": "numpy.full(0)",
            "C": "numpy.zeros()",
            "D": "numpy.null_array()"
          },
          "correct_answer": "C",
          "explanation": "The `numpy.zeros()` function is specifically designed to create a new array of a given shape and type, filled with zeros. For example, `np.zeros((2, 3))` would create a 2x3 array of zeros."
        },
        {
          "question": "Which NumPy function can create an array filled with a specified value?",
          "options": {
            "A": "numpy.zeros()",
            "B": "numpy.ones()",
            "C": "numpy.full()",
            "D": "numpy.repeat()"
          },
          "correct_answer": "C",
          "explanation": "The `numpy.full()` function creates an array of a given shape and fills it with a specified fill value. For example, `np.full((2, 2), 7)` would create a 2x2 array where all elements are 7."
        },
        {
          "question": "What NumPy function is used to generate a sequence of numbers within a specified range?",
          "options": {
            "A": "numpy.sequence()",
            "B": "numpy.range()",
            "C": "numpy.arange()",
            "D": "numpy.linspace()"
          },
          "correct_answer": "C",
          "explanation": "The `numpy.arange()` function is used to generate a sequence of numbers, similar to Python's built-in `range()` function, but it returns a NumPy array. It takes `start`, `stop`, and `step` arguments. For example, `np.arange(0, 10, 2)` would produce `[0, 2, 4, 6, 8]`."
        },
        {
          "question": "Which NumPy function generates evenly spaced numbers over a specified interval?",
          "options": {
            "A": "numpy.arange()",
            "B": "numpy.random.rand()",
            "C": "numpy.linspace()",
            "D": "numpy.eye()"
          },
          "correct_answer": "C",
          "explanation": "The `numpy.linspace()` function generates a specified number of evenly spaced values within a given interval. It takes `start`, `stop`, and `num` (number of samples) arguments. For example, `np.linspace(0, 1, 5)` would produce `[0.0, 0.25, 0.5, 0.75, 1.0]`."
        },
        {
          "question": "How do you access the element at the second row and third column of a 2D NumPy array named 'arr'?",
          "options": {
            "A": "arr[2, 3]",
            "B": "arr(2)(3)",
            "C": "arr[1][2]",
            "D": "Both B and C"
          },
          "correct_answer": "C",
          "explanation": "NumPy uses zero-based indexing. So, the second row is at index 1, and the third column is at index 2. You can access elements using `arr[row_index, column_index]` (e.g., `arr[1, 2]`) or chained indexing `arr[row_index][column_index]` (e.g., `arr[1][2]`). Both `arr[1, 2]` and `arr[1][2]` are valid for accessing elements in a 2D array, but `arr[1, 2]` is generally preferred for performance and clarity."
        },
        {
          "question": "What does the slicing `arr[1:5]` do to a 1D NumPy array 'arr'?",
          "options": {
            "A": "It selects elements from index 1 to 5 (inclusive).",
            "B": "It selects elements from index 1 to 4 (inclusive).",
            "C": "It selects elements from index 0 to 4 (inclusive).",
            "D": "It selects elements starting from index 1 until the end of the array."
          },
          "correct_answer": "B",
          "explanation": "In Python (and NumPy), slicing `[start:end]` includes elements from `start` up to, but **not including**, `end`. Therefore, `arr[1:5]` selects elements with indices 1, 2, 3, and 4."
        },
        {
          "question": "What is boolean indexing in NumPy?",
          "options": {
            "A": "Indexing arrays using only True or False values to select elements.",
            "B": "Indexing arrays using boolean data types.",
            "C": "A method to check if an element exists in an array.",
            "D": "Indexing arrays based on comparison operations."
          },
          "correct_answer": "A",
          "explanation": "**Boolean indexing** (also known as boolean masking) in NumPy allows you to select elements from an array based on a boolean array of the same shape. Where the boolean array is `True`, the corresponding element from the original array is selected. This is often achieved by applying a comparison operation directly to the array, which returns a boolean array."
        },
        {
          "question": "What is fancy indexing in NumPy?",
          "options": {
            "A": "Indexing arrays using a single integer or slice.",
            "B": "Indexing arrays using other arrays of indices to select elements in a specific order or multiple times.",
            "C": "Indexing arrays based on boolean conditions.",
            "D": "Indexing arrays from the end using negative indices."
          },
          "correct_answer": "B",
          "explanation": "**Fancy indexing** in NumPy refers to indexing using arrays of integers (or lists of integers) to select specific elements. This allows for selecting non-contiguous elements or selecting elements multiple times, and the resulting array will have the same shape as the index array."
        },
        {
          "question": "Which NumPy method can be used to change the shape of an array without changing its data?",
          "options": {
            "A": "array.resize()",
            "B": "array.reshape()",
            "C": "array.shape()",
            "D": "array.flatten()"
          },
          "correct_answer": "B",
          "explanation": "The `array.reshape()` method allows you to change the shape of an array while keeping its data. It returns a *new* array with the specified shape, or a view of the original array if possible, without modifying the original array's data. The new shape must be compatible with the original number of elements."
        },
        {
          "question": "How can you swap the rows and columns of a 2D NumPy array 'arr'?",
          "options": {
            "A": "arr.swapaxes(0, 1)",
            "B": "arr.transpose()",
            "C": "arr.T",
            "D": "All of the above"
          },
          "correct_answer": "D",
          "explanation": "All three options are valid ways to swap rows and columns (transpose) a 2D NumPy array: \n- `arr.swapaxes(0, 1)` swaps the axes at positions 0 and 1.\n- `arr.transpose()` returns the transposed array.\n- `arr.T` is a convenient shorthand attribute for the transpose of the array. For 2D arrays, all achieve the same result of swapping rows and columns."
        },
        {
          "question": "Which NumPy function can be used to combine multiple arrays along an existing axis?",
          "options": {
            "A": "numpy.concatenate()",
            "B": "numpy.stack()",
            "C": "numpy.split()",
            "D": "numpy.merge()"
          },
          "correct_answer": "A",
          "explanation": "The `numpy.concatenate()` function is used to join a sequence of arrays along an existing axis. You specify the arrays to join and the `axis` along which to join them. For example, concatenating along `axis=0` stacks them row-wise, and along `axis=1` stacks them column-wise."
        },
        {
          "question": "What is 'broadcasting' in NumPy?",
          "options": {
            "A": "A method to transmit data between different computers using NumPy arrays.",
            "B": "A set of rules that allow NumPy to perform arithmetic operations on arrays with different shapes.",
            "C": "A technique for displaying NumPy arrays in a formatted way.",
            "D": "A way to convert NumPy arrays to other data structures."
          },
          "correct_answer": "B",
          "explanation": "**Broadcasting** is a powerful mechanism in NumPy that allows arithmetic operations (like addition, subtraction, multiplication) to be performed on arrays of different shapes. NumPy automatically 'stretches' the smaller array across the larger array so that they have compatible shapes for the operation, without actually duplicating data."
        },
        {
          "question": "Which NumPy function calculates the sine of each element in an array?",
          "options": {
            "A": "numpy.cos()",
            "B": "numpy.tan()",
            "C": "numpy.sin()",
            "D": "numpy.arcsin()"
          },
          "correct_answer": "C",
          "explanation": "NumPy provides a wide range of universal functions (ufuncs) that operate element-wise on arrays. `numpy.sin()` is one such ufunc that calculates the sine of each element in the input array. Similarly, `numpy.cos()` and `numpy.tan()` calculate cosine and tangent, respectively."
        }
      ]
    }
  ]
}
