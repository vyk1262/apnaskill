{
  "result": [
    {
      "topic": "Array_Indexing_and_Slicing",
      "questions": [
        {
          "question": "How do you access the element at the first row and first column of a 2D NumPy array named `data`?",
          "options": {
            "A": "data[0][0]",
            "B": "data(0, 0)",
            "C": "data[1, 1]",
            "D": "data{0, 0}"
          },
          "correct_answer": "A",
          "explanation": "NumPy arrays are 0-indexed, meaning the first element is at index 0. For a 2D array, you access elements using `array[row_index][column_index]` or, more commonly and efficiently in NumPy, `array[row_index, column_index]`."
        },
        {
          "question": "What does negative indexing in NumPy arrays allow you to do?",
          "options": {
            "A": "Access elements with negative values.",
            "B": "Access elements from the end of the array.",
            "C": "Create a reversed copy of the array.",
            "D": "Skip elements during slicing."
          },
          "correct_answer": "B",
          "explanation": "Negative indices in NumPy (and Python lists) count from the end of the array. For example, `-1` refers to the last element, `-2` to the second-to-last, and so on."
        },
        {
          "question": "For a 1D NumPy array `arr = [10, 20, 30, 40, 50]`, what is the result of `arr[-2]`?",
          "options": {
            "A": "10",
            "B": "40",
            "C": "50",
            "D": "IndexError"
          },
          "correct_answer": "B",
          "explanation": "Negative indexing counts from the end. `arr[-1]` is 50, and `arr[-2]` is 40."
        },
        {
          "question": "Given a 2D NumPy array `matrix`, how would you extract the entire first row?",
          "options": {
            "A": "matrix[0]",
            "B": "matrix[:, 0]",
            "C": "matrix[0, :]",
            "D": "matrix(0)"
          },
          "correct_answer": "A",
          "explanation": "For a 2D array, `matrix[0]` directly selects the first row. `matrix[0, :]` also achieves this, explicitly stating that all columns are selected from the first row. `matrix[:, 0]` would select the first column."
        },
        {
          "question": "Given a 2D NumPy array `matrix`, how would you extract the entire first column?",
          "options": {
            "A": "matrix[0]",
            "B": "matrix[:, 0]",
            "C": "matrix[0, :]",
            "D": "matrix(:, 1)"
          },
          "correct_answer": "B",
          "explanation": "To extract an entire column, you use the slice `:` to indicate all rows, and then specify the column index. So, `matrix[:, 0]` selects all rows (represented by `:`) and the first column (represented by `0`)."
        },
        {
          "question": "For a 1D NumPy array `arr = [2, 4, 6, 8, 10]`, what is the result of `arr[1:4]`?",
          "options": {
            "A": "[2, 4, 6]",
            "B": "[4, 6, 8]",
            "C": "[4, 6, 8, 10]",
            "D": "[2, 4, 6, 8]"
          },
          "correct_answer": "B",
          "explanation": "Slicing in Python (and NumPy) is `[start:stop]`, where `start` is inclusive and `stop` is exclusive. So, `arr[1:4]` includes elements at index 1, 2, and 3: which are 4, 6, and 8 respectively."
        },
        {
          "question": "What does the step value in array slicing (e.g., `arr[start:stop:step]`) control?",
          "options": {
            "A": "The starting index of the slice.",
            "B": "The ending index of the slice (exclusive).",
            "C": "The increment between indices in the slice.",
            "D": "The number of elements to include in the slice."
          },
          "correct_answer": "C",
          "explanation": "The `step` value determines how many elements to jump over between each selected element in the slice. A step of 2 means every other element, -1 means reverse, etc."
        },
        {
          "question": "For a 1D NumPy array `arr = [1, 2, 3, 4, 5]`, what is the result of `arr[::2]`?",
          "options": {
            "A": "[1, 2, 3, 4, 5]",
            "B": "[2, 4]",
            "C": "[1, 3, 5]",
            "D": "[5, 3, 1]"
          },
          "correct_answer": "C",
          "explanation": "`arr[::2]` means start from the beginning (default `start`), go to the end (default `stop`), and take every second element. So, it selects elements at indices 0, 2, and 4: which are 1, 3, and 5."
        },
        {
          "question": "How can you reverse a 1D NumPy array `arr` using slicing?",
          "options": {
            "A": "arr.reverse()",
            "B": "arr[::-1]",
            "C": "arr.slice(None, None, -1)",
            "D": "numpy.flip(arr)"
          },
          "correct_answer": "B",
          "explanation": "The slice `[::-1]` is a common and concise way to reverse an array in Python and NumPy. It means start at the end, go to the beginning, with a step of -1 (moving backwards). `numpy.flip(arr)` also reverses the array but is a dedicated function."
        },
        {
          "question": "What is boolean indexing used for in NumPy arrays?",
          "options": {
            "A": "Accessing elements based on their position.",
            "B": "Selecting elements based on a boolean array of the same shape.",
            "C": "Converting array elements to boolean type.",
            "D": "Checking if an array is empty."
          },
          "correct_answer": "B",
          "explanation": "Boolean indexing (also known as boolean masking) involves using a boolean array of the same shape as the original array to select elements. Where the boolean array has `True`, the corresponding element from the original array is selected; where it's `False`, it's not."
        },
        {
          "question": "Given `arr = np.array([1, 2, 3, 4, 5])` and `mask = np.array([True, False, True, False, True])`, what is the result of `arr[mask]`?",
          "options": {
            "A": "[True, False, True, False, True]",
            "B": "[1, 3, 5]",
            "C": "[2, 4]",
            "D": "[1, 2, 3, 4, 5]"
          },
          "correct_answer": "B",
          "explanation": "When using boolean indexing, only the elements in `arr` that correspond to `True` values in `mask` are selected. So, elements at index 0, 2, and 4 (which are 1, 3, and 5) are returned."
        },
        {
          "question": "What is fancy indexing in NumPy?",
          "options": {
            "A": "Indexing with negative numbers.",
            "B": "Indexing with a single scalar value.",
            "C": "Indexing with integer arrays to select elements at specific indices.",
            "D": "Indexing multi-dimensional arrays."
          },
          "correct_answer": "C",
          "explanation": "Fancy indexing allows you to select non-contiguous or non-sequential elements from an array using an array (or list) of integer indices. The resulting array will have the shape of the index array."
        },
        {
          "question": "Given `arr = np.array([10, 20, 30, 40, 50])` and `indices = np.array([0, 3, 1])`, what is the result of `arr[indices]`?",
          "options": {
            "A": "[10, 20, 30]",
            "B": "[10, 40, 20]",
            "C": "[0, 3, 1]",
            "D": "[50, 40, 30]"
          },
          "correct_answer": "B",
          "explanation": "Fancy indexing uses the values in the `indices` array as the actual indices to retrieve elements from `arr`. So, `arr[0]` is 10, `arr[3]` is 40, and `arr[1]` is 20, resulting in `[10, 40, 20]`."
        },
        {
          "question": "Can fancy indexing be used to modify array elements?",
          "options": {
            "A": "No, it only allows for reading elements.",
            "B": "Yes, you can assign new values to the selected elements.",
            "C": "Only for 1D arrays.",
            "D": "Only for boolean indexing."
          },
          "correct_answer": "B",
          "explanation": "Yes, fancy indexing can be used on the left-hand side of an assignment to modify specific elements. For example, `arr[[0, 3, 1]] = [100, 400, 200]` would update the elements at those indices."
        },
        {
          "question": "Given a 2D array `data`, how would you select the elements at the intersections of rows [0, 2] and columns [1, 3] using fancy indexing?",
          "options": {
            "A": "data[[0, 2], [1, 3]]",
            "B": "data[[0, 1], [2, 3]]",
            "C": "data[0:3:2, 1:4:2]",
            "D": "data[np.ix_([0, 2], [1, 3])]"
          },
          "correct_answer": "A",
          "explanation": "When using multiple integer arrays for fancy indexing, the arrays are paired up (e.g., `(0,1)` and `(2,3)`). This selects `data[0,1]` and `data[2,3]`. If you want a grid selection (all combinations), you would use `np.ix_`, as shown in option D."
        },
        {
          "question": "What is the difference between `arr[1:3]` and `arr[[1, 2]]` for a 1D array `arr`?",
          "options": {
            "A": "They produce the same result.",
            "B": "`arr[1:3]` returns a slice (a view), while `arr[[1, 2]]` returns a copy (using fancy indexing).",
            "C": "`arr[1:3]` uses boolean indexing, while `arr[[1, 2]]` uses integer indexing.",
            "D": "`arr[1:3]` includes the element at index 3, while `arr[[1, 2]]` does not."
          },
          "correct_answer": "B",
          "explanation": "Slicing (`arr[1:3]`) returns a *view* into the original array's data; changes to the slice will affect the original array. Fancy indexing (`arr[[1, 2]]`) always returns a *copy* of the data; changes to the copied array will not affect the original."
        },
        {
          "question": "How can you select all elements in a 2D array `matrix` where the second column is greater than 5?",
          "options": {
            "A": "matrix[matrix[:, 1] > 5]",
            "B": "matrix[:, matrix[1] > 5]",
            "C": "matrix[matrix[1, :] > 5]",
            "D": "matrix(where(matrix[:, 1] > 5))"
          },
          "correct_answer": "A",
          "explanation": "First, `matrix[:, 1]` extracts the entire second column. Then, `matrix[:, 1] > 5` creates a boolean array (mask) where `True` indicates values greater than 5 in that column. Finally, `matrix[mask]` uses this boolean mask to select the *rows* from `matrix` where the condition is True in the second column."
        },
        {
          "question": "What happens if you try to index a NumPy array with an index that is out of bounds?",
          "options": {
            "A": "The array is resized automatically.",
            "B": "It returns the last element.",
            "C": "It raises an IndexError.",
            "D": "It returns 0."
          },
          "correct_answer": "C",
          "explanation": "Attempting to access an element using an index that is outside the valid range of indices for that dimension will result in an `IndexError`."
        },
        {
          "question": "Can you use a list of boolean values for indexing a NumPy array?",
          "options": {
            "A": "No, only NumPy arrays of booleans are allowed.",
            "B": "Yes, Python lists of booleans are automatically converted to NumPy boolean arrays for indexing.",
            "C": "Only for 1D arrays.",
            "D": "Only if the list has the same length as the array."
          },
          "correct_answer": "B",
          "explanation": "NumPy is flexible and will automatically convert a Python list of boolean values into a NumPy boolean array when used for indexing, provided the list's length matches the dimension being indexed."
        },
        {
          "question": "Given a 3D array `tensor`, how would you access the element at the first 'layer', second row, and third column?",
          "options": {
            "A": "tensor[1, 2, 3]",
            "B": "tensor[0][1][2]",
            "C": "tensor(0, 1, 2)",
            "D": "Both A and B"
          },
          "correct_answer": "D",
          "explanation": "Both `tensor[0, 1, 2]` (using comma separation, which is the idiomatic NumPy way) and `tensor[0][1][2]` (using successive bracket notation, common in Python for nested lists) correctly access the element at the specified 0-indexed positions: first layer (index 0), second row (index 1), and third column (index 2)."
        }
      ]
    }
  ]
}
