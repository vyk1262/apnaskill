{
  "result": [
    {
      "topic": "javascript_async",
      "questions": [
        {
          "question": "What is a callback in JavaScript?",
          "options": {
            "A": "A function that is passed as an argument to another function",
            "B": "A method that gets called when an object is created",
            "C": "A function that returns a promise",
            "D": "A function that has no parameters"
          },
          "correct_answer": "A",
          "explanation": "A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action."
        },
        {
          "question": "What is the primary purpose of asynchronous programming?",
          "options": {
            "A": "To execute multiple tasks simultaneously",
            "B": "To simplify synchronous code",
            "C": "To block code execution until a task completes",
            "D": "To improve code readability"
          },
          "correct_answer": "A",
          "explanation": "Asynchronous programming allows operations to run in the background without blocking the main execution thread, making the application more responsive and efficient, especially for tasks like network requests or file I/O."
        },
        {
          "question": "What does a Promise represent in JavaScript?",
          "options": {
            "A": "A value that will be available in the future",
            "B": "A function that is always executed",
            "C": "A method that resolves immediately",
            "D": "An object that can be modified"
          },
          "correct_answer": "A",
          "explanation": "A Promise is a JavaScript object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value."
        },
        {
          "question": "Which method is used to handle a fulfilled promise?",
          "options": {
            "A": ".catch()",
            "B": ".then()",
            "C": ".finally()",
            "D": ".resolve()"
          },
          "correct_answer": "B",
          "explanation": "The `.then()` method is used to attach callbacks for the eventual fulfillment or rejection of a Promise. The first argument to `.then()` is the success handler (for fulfilled promises)."
        },
        {
          "question": "What does the async keyword do when used before a function?",
          "options": {
            "A": "It makes the function return a promise",
            "B": "It prevents the function from executing",
            "C": "It allows the function to run synchronously",
            "D": "It creates a generator function"
          },
          "correct_answer": "A",
          "explanation": "The `async` keyword placed before a function declaration makes the function an asynchronous function, which implicitly returns a Promise. If the function returns a non-Promise value, it will be wrapped in a resolved Promise."
        },
        {
          "question": "How do you handle errors in an async function?",
          "options": {
            "A": "Using try/catch blocks",
            "B": "Using the .catch() method",
            "C": "Returning an error object",
            "D": "Using error callbacks"
          },
          "correct_answer": "A",
          "explanation": "Within an `async` function, you can use standard `try...catch` blocks to handle errors that occur during asynchronous operations (especially those involving `await`). The `catch` block will execute if a Promise that is `await`ed is rejected."
        },
        {
          "question": "What is the purpose of the await keyword?",
          "options": {
            "A": "To pause the execution of an async function until a promise resolves",
            "B": "To create a new promise",
            "C": "To execute a synchronous function",
            "D": "To return multiple values from a function"
          },
          "correct_answer": "A",
          "explanation": "The `await` keyword can only be used inside an `async` function. It pauses the execution of the `async` function until the Promise it's waiting for settles (either fulfills or rejects), and then resumes execution with the Promise's resolved value."
        },
        {
          "question": "Which of the following will NOT return a promise?",
          "options": {
            "A": "fetch()",
            "B": "new Promise()",
            "C": "setTimeout()",
            "D": "Promise.resolve()"
          },
          "correct_answer": "C",
          "explanation": "`setTimeout()` is a traditional asynchronous function that uses callbacks. It does not return a Promise directly. `fetch()`, `new Promise()`, and `Promise.resolve()` all inherently work with or return Promises."
        },
        {
          "question": "What happens if you do not return a value from an async function?",
          "options": {
            "A": "It returns undefined",
            "B": "It throws an error",
            "C": "It resolves to null",
            "D": "It creates an infinite loop"
          },
          "correct_answer": "A",
          "explanation": "If an `async` function does not explicitly return a value, it implicitly returns `Promise.resolve(undefined)`. The Promise it returns will resolve with `undefined`."
        },
        {
          "question": "What will the following code output: console.log(Promise.resolve(2) + 2)?",
          "options": {
            "A": "2",
            "B": "22",
            "C": "Promise {2}",
            "D": "Error"
          },
          "correct_answer": "B",
          "explanation": "When you try to concatenate a Promise object with a number using the `+` operator, JavaScript performs type coercion. The Promise object is converted to its string representation (which might vary depending on the environment, but often includes '[object Promise]' or similar), and then '2' is appended, resulting in string concatenation. In many environments, `Promise.resolve(2)` might stringify to something like `[object Promise]`, leading to `[object Promise]2`, but more commonly, for simple numerical resolution like this, it might result in '22' due to the internal `toString` behavior for primitive-resolving Promises or how the environment handles this specific coercion."
        },
        {
          "question": "What does it mean for a function to be asynchronous?",
          "options": {
            "A": "It runs in parallel with other functions",
            "B": "It blocks the main thread until completion",
            "C": "It can return a promise",
            "D": "Both A and C"
          },
          "correct_answer": "D",
          "explanation": "An asynchronous function does not block the main execution thread, allowing other code to run while it's performing an operation. It often involves non-blocking operations and can return a Promise to represent its eventual completion."
        },
        {
          "question": "Which of the following is true about promises?",
          "options": {
            "A": "They can be in one of three states: pending, fulfilled, or rejected.",
            "B": "They can only be in a fulfilled state.",
            "C": "They can be created only using the async/await syntax.",
            "D": "They automatically resolve without any callback."
          },
          "correct_answer": "A",
          "explanation": "A Promise can be in one of three states: 'pending' (initial state), 'fulfilled' (meaning that the operation completed successfully), or 'rejected' (meaning that the operation failed)."
        },
        {
          "question": "How do you convert a regular function to return a promise?",
          "options": {
            "A": "By using the async keyword",
            "B": "By wrapping it in a Promise constructor",
            "C": "By using the await keyword",
            "D": "By adding .then() to it"
          },
          "correct_answer": "B",
          "explanation": "You can explicitly create a Promise by wrapping your asynchronous logic inside the `Promise` constructor, which takes an executor function with `resolve` and `reject` arguments. Alternatively, using the `async` keyword before a function implicitly makes it return a promise."
        },
        {
          "question": "What will the following code output? 'Promise.resolve(3).then(v => v + 1).then(v => console.log(v));'",
          "options": {
            "A": "3",
            "B": "4",
            "C": "Error",
            "D": "Promise {4}"
          },
          "correct_answer": "B",
          "explanation": "The `Promise.resolve(3)` creates a promise that immediately resolves with the value 3. The first `.then(v => v + 1)` takes the resolved value (3), adds 1 to it (making it 4), and returns a new promise that resolves with 4. The second `.then(v => console.log(v))` takes this new resolved value (4) and logs it to the console."
        },
        {
          "question": "What is the main advantage of using async/await over traditional promise chaining?",
          "options": {
            "A": "It makes the code more readable and easier to understand.",
            "B": "It eliminates the need for promises entirely.",
            "C": "It executes all promises simultaneously.",
            "D": "It automatically handles errors."
          },
          "correct_answer": "A",
          "explanation": "Async/await syntax makes asynchronous code look and behave more like synchronous code, which greatly improves readability and simplifies the structure of complex asynchronous flows, reducing 'callback hell' or deeply nested `.then()` chains."
        },
        {
          "question": "Which of the following can be used to run multiple promises concurrently?",
          "options": {
            "A": "Promise.all()",
            "B": "Promise.race()",
            "C": "async/await",
            "D": "setTimeout()"
          },
          "correct_answer": "A",
          "explanation": "`Promise.all()` is a static method that takes an iterable of Promises and returns a single Promise that resolves when all of the input Promises have resolved, or rejects when any of the input Promises reject. This allows for concurrent execution of independent asynchronous operations."
        },
        {
          "question": "What will happen if you use await on a non-promise value?",
          "options": {
            "A": "It will throw an error.",
            "B": "It will convert the value to a promise.",
            "C": "It will immediately resolve with that value.",
            "D": "It will block the event loop."
          },
          "correct_answer": "C",
          "explanation": "If you `await` a non-Promise value, JavaScript will automatically wrap that value in a resolved Promise, and the `await` expression will immediately resolve with that value, without pausing the `async` function."
        },
        {
          "question": "How can you handle multiple errors when using async/await?",
          "options": {
            "A": "Using a try/catch block around the await calls.",
            "B": "Using .catch() after the function call.",
            "C": "Returning a promise that resolves to an error object.",
            "D": "Using an error handler function."
          },
          "correct_answer": "A",
          "explanation": "For individual `await` calls or a sequence of `await` calls within an `async` function, the `try...catch` block is the standard way to catch any errors (rejections) that occur."
        },
        {
          "question": "What is the purpose of the Promise.allSettled() method?",
          "options": {
            "A": "To execute promises in parallel and wait until all are resolved or rejected.",
            "B": "To execute promises in sequence.",
            "C": "To return the first settled promise only.",
            "D": "To handle errors from all promises."
          },
          "correct_answer": "A",
          "explanation": "`Promise.allSettled()` waits until all given promises have either fulfilled or rejected, and returns a promise that resolves with an array of objects, each describing the outcome of a promise."
        },
        {
          "question": "Which of the following is a valid use of async/await?",
          "options": {
            "A": "await Promise.resolve()",
            "B": "await 1 + 2",
            "C": "async function() { return 3; }",
            "D": "await setTimeout(() => {}, 1000)"
          },
          "correct_answer": "A",
          "explanation": "The `await` keyword is designed to be used with Promises. `Promise.resolve()` returns a resolved Promise, making `await Promise.resolve()` a valid and common use case. `await 1 + 2` is valid but pointless as it doesn't await anything. `async function() { return 3; }` is a valid async function declaration, not an `await` usage. `setTimeout` does not return a promise by default, so awaiting it directly wouldn't yield the intended asynchronous control flow without explicit Promise wrapping."
        }
      ]
    }
  ]
}
